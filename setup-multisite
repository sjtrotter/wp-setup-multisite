#!/usr/bin/env bash

# this is a new comment to test.

# Pulling out a clearer understanding of what exactly we are doing.
# - creating new wordpress config
#   - copying wp-content into /srv/ to serve it from
#   - writing wordpress config for new site
#   - creating new database table, database user, and database user password for site;
# - destroying wordpress config
#   - reading config for site
#   - dropping all tables in database
#   - deleting wp-content IF NOT /var/lib/wordpress/wp-content
#   - deleting wordpress config

#     - would like to support local database
#     - would like to support remote database
#     - would like to support default debian "secure mysql config"
#     - would like to support non-standard mysql config, i.e. user/pass

# TODO
# ===========
# [ inwork ] reorganize current codebase
# [ inwork ] write parse_args
# [  done  ] check number of args passed
# [  done  ] sanitize FQDN
# [ inwork ] implement debug verbosity
# [  done  ] import finish, debug, version functions
# [  done  ] hook imported functions into parse_args
# [  done  ] utilize finish for all error exits
# [  todo  ] prereqs - check for all needed commands, prompt to install? i.e. mysql
# [  todo  ] prereqs - check for needed files, prompt to install? i.e. wordpress
# [  todo  ] inputs - need to separate 'name' from 'db_user'
# [  todo  ] destroy - pull db configs from file to destroy
# ==========
# [   33%  ] - v0.5.0


# This script is versioned with Semantic Versioning. https://semver.org
readonly VERSION="0.5.0"
# Errors
readonly ERR_UNK_OPT="64"
readonly ERR_TOO_MANY_ARGS="65"
readonly ERR_NO_FQDN="66"
readonly ERR_MUST_BE_ROOT="67"
readonly ERR_INVALID_FQDN="68"
readonly ERR_DOMAIN_UNREACHABLE="69"
readonly ERR_NO_WORDPRESS="70"
# Script-specific constants
readonly WP_CONTENT_DIR="/var/lib/wordpress/wp-content"
readonly WP_ETC_DIR="/etc/wordpress"
readonly FQDN_VALID="^([a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]\.)+[a-zA-Z]{2,}$"
# Colors
readonly ANSI_RED="\033[1;31m"
readonly ANSI_CLEAR="\033[0m"
readonly ANSI_YELLOW="\033[1;93m"
# Unset boolean/control vars
unset DEBUG
unset BACKUP
unset DESTROY
unset WP_CONFIG
# Define vars
ARGS=()
declare -A WP_CONFIG
# DB_NAME - passed at cli, or generated from fqdn
# DB_USER - passed at cli, or generated from fqdn
# DB_PASSWORD - Generated? or allow user to set at cli
# DB_HOST - passed at cli, or assumed localhost
# SECRET_KEY - Generated
# WP_CONTENT_DIR - Generated from FQDN

finish () {
    local rc="$1"
    shift
    local msg="$@"
    if [[ "${rc}" -gt 0 ]]; then
        printf "${ANSI_RED}%s: %s${ANSI_CLEAR}\n" "$(basename $0)" "${msg}"
        printf "Try: $(basename $0) -h\n"
    fi
    exit "${rc}"
} >&2

debug () {
    local msg="$@"
    if [[ "${DEBUG}" ]]; then
        printf "${ANSI_YELLOW}[-]${ANSI_CLEAR} %s\n" "${msg}" >&2
    fi
}

version () {
    printf "${VERSION}\n"
}

usage() {
cat <<EOF
$0 [-h | -d | -b] [-n NAME | -e DB Name] [-u MySQL user] [-t MySQL host] FQDN

Creates by default a Wordpress mysql configuration depending on required fully
qualified domain name(FQDN).

Options:
    -n name for the wordpress site; see also -e below
    -h help
    -d destroy and purge
    -b backup
    -u mysql username, will require password
    -t mysql server hostname, if unset localhost will be used
    -e existing empty mysql database name; will replace -n

Example: You want your blog to be served from http://blog.example.com
         for user 'wordpress'.

Then run:
sudo bash setup-mysql -n wordpress blog.example.com

EOF
}

checkforexistingsetup() {
    if [ -f $CONFIG_FILE ] ; then
        echo WARNING: $CONFIG_FILE exists!
        finish "${ERR_CONFIG_EXISTS}" "config exists: ${CONFIG_FILE}"
    fi
    
    # Generate a random password without Perl
    MATRIX=",.[]<>?:{}!@#$^&*()_+-=0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    if [ ! $MYSQLUSER ]; then
        LENGTH="8"
        while [ "${n:=1}" -le "$LENGTH" ]
        do
            DB_PASSWORD="$DB_PASSWORD${MATRIX:$(($RANDOM%${#MATRIX})):1}"
            let n+=1
        done
        DB_USER=$NAME
    else
        DB_USER=$MYSQLUSER
        echo "Enter MySQL password for user $DB_USER."
        read -p "> " DB_PASSWORD
    fi
    
    LENGTH="50"
    while [ "${n:=1}" -le "$LENGTH" ]
    do
        SECRET_KEY="$SECRET_KEY${MATRIX:$(($RANDOM%${#MATRIX})):1}"
        let n+=1
    done
    
    if [ ! $DB_DB ]; then
        DB_NAME=$NAME
    else
        DB_NAME=$DB_DB
    fi
    
    # Write the config file for wordpress
    printf "<?php\n" >> $CONFIG_FILE
    printf "# Created by $0\n" >> $CONFIG_FILE

    # LOOP TO BE USED WHEN ASSOCIATIVE ARRAY IS WORKING
    # for key in ${WP_CONFIG[@]}; do
    #     printf "    define('${key}', '${WP_CONFIG[key]}');\n" >> $CONFIG_FILE
    # done
    printf "define('DB_NAME', '$DB_NAME');\n" >> $CONFIG_FILE
    printf "define('DB_USER', '$DB_USER');\n" >> $CONFIG_FILE
    printf "define('DB_PASSWORD', '$DB_PASSWORD');\n" >> $CONFIG_FILE
    printf "define('DB_HOST', '$DB_HOST');\n" >> $CONFIG_FILE
    printf "define('SECRET_KEY', '$SECRET_KEY');\n" >> $CONFIG_FILE
    printf "define('WP_CONTENT_DIR', '$CONTENT');\n" >> $CONFIG_FILE
    # LOOP ENDS HERE

    printf "define('FS_METHOD', 'direct');\n" >> $CONFIG_FILE
    printf "?>\n" >> $CONFIG_FILE
    # Set permissions
    chmod g+r "${CONFIG_FILE}"
    chgrp www-data "${CONFIG_FILE}"
    echo $CONFIG_FILE written
}

create() {
# Create the database and user
# Wordpress's install.php creates the tables btw
if [ ! $DB_DB ]; then
    MYSQLCOMMAND="mysql -u $DB_USER -p -h $DB_HOST"
    $MYSQLCOMMAND <<EOF
CREATE DATABASE $NAME;
GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER
ON $DB_NAME.*
TO $DB_USER@$DB_HOST
IDENTIFIED BY '$DB_PASSWORD';
FLUSH PRIVILEGES;
EOF
fi

echo Goto http://$DOMAIN to setup Wordpress
}

backup() {
echo Enter root password for mysql:
BACKUPFILE=/tmp/blog-$NAME.bak.sql.bz2
mysqldump --add-drop-table -u root -p $NAME | bzip2 -c > $BACKUPFILE && echo Wrote $BACKUPFILE
}

destroy() {
# The destroy method need root to be able to drop databases and such.
# People using complex setups with remote servers probably know how to
# cleanup after the user any way.
if [ ! -e /etc/mysql/debian.cnf ]; then
    finish "${ERR_MYSQL_SETTINGS_NOT_AVAILABLE}" "manual database cleanup required"
fi
echo Destroying $NAME
prompt
mysql --defaults-extra-file=/etc/mysql/debian.cnf <<EOF
CONNECT mysql;
DELETE FROM user where user='$NAME';
DELETE FROM db WHERE User = '$NAME';
DELETE FROM tables_priv WHERE User = '$NAME';
DELETE FROM columns_priv WHERE User = '$NAME';
FLUSH PRIVILEGES ;
DROP DATABASE IF EXISTS $NAME;
EOF
rm $CONFIG_FILE
}

prompt() {
while true; do
  echo -n "Are you sure? (y/n) "
  read yn
  case $yn in
    y* | Y* ) break ;;
    [nN]* )   finish "0" "" ; break ;;
    * ) echo "unknown response.  Asking again" ;;
  esac
done
}


parse_args () {

    optstring=":n:hbdu:t:e:vV"

    while [[ ${OPTIND} -le "$#" ]]; do
        if getopts ${optstring} arg; then
            case ${arg} in
                h) usage; finish 0 "" ;;
                b) BACKUP=1 ;;
                d) DESTROY=1 ;;
                n) NAME="${OPTARG}" ;;
                u) MYSQLUSER="${OPTARG}" ;;
                t) DB_HOST="${OPTARG}" ;;
                v) DEBUG=yes ;;
                V) version; finish 0 "" ;;
                e) DB_DB="${OPTARG}" ;;
                *) finish "${ERR_UNK_OPT}" "unknown option: -${OPTARG}" ;;
            esac
        else
            ARGS+=("${!OPTIND}")
            ((OPTIND++))
        fi    
    done

    debug "testing FQDN: ${ARGS[@]} ..."
    debug "... is there one?"
    if [[ ${#ARGS[@]} -lt 1 ]]; then
        finish $ERR_NO_FQDN "no FQDN given"
    fi
    debug "... is there too many?"
    if [[ ${#ARGS[@]} -gt 1 ]]; then
        finish "${ERR_TOO_MANY_ARGS}" "too many arguments: ${ARGS[@]}"
    fi
    debug "... is it valid?"
    if [[ ! "${ARGS[0]}" =~ $FQDN_VALID ]]; then
        finish "${ERR_INVALID_FQDN}" "invalid FQDN given: ${ARGS[0]}"
    fi
}



main() {
    parse_args "$@"

# WP_CONTENT[key] = "${value}"
# 'DB_NAME'
# 'DB_USER'
# 'DB_PASSWORD 
# 'DB_HOST'
# 'SECRET_KEY'
# 'WP_CONTENT_DIR'

    DOMAIN=$(echo "${ARGS[0]}" | tr "[:upper:]" "[:lower:]")
    CONTENT="/var/lib/wordpress/wp-content"
    
    # skip ping. why does the server have to be online?
    # -- I think this was to ensure the domain name is valid; using regex now.
    # if [ $DOMAIN ] ; then
    #     ping -c 1 `echo $DOMAIN | sed 's/:[0-9]\+//'` || finish "${ERR_DOMAIN_UNREACHABLE}" "can't reach ${DOMAIN}"
    # fi
    
    CONFIG_FILE=/etc/wordpress/config-$DOMAIN.php
    
    if [ ! $NAME ] ; then
        NAME=$(echo $DOMAIN | sed 's,\.,,g;s,-,,g')
        echo Constructed database name and user: $NAME from $DOMAIN
    fi
    
    if [ ${#NAME} -gt 16 ]; then
        finish "${ERR_MYSQL_USER_TOO_LONG}" "MYSQL user ${NAME} should be 16 characters or less"
    fi
    
    if [ ! $DB_HOST ]; then
        DB_HOST="localhost"
    fi


    if [ $BACKUP ] ; then
        backup
        finish "0" ""
    fi
    
    if [ $DESTROY ] ; then
        destroy
        finish "0" ""
    fi

    checkforexistingsetup
    create
 }



# prereqs
if [[ "$(id -u)" != "0" ]]; then finish "${ERR_MUST_BE_ROOT}" "must be root"; fi
if [[ ! -d "${WP_ETC_DIR}" ]]; then finish "${ERR_NO_WORDPRESS}" "${WP_ETC_DIR} not found - is wordpress installed?"; fi
if [[ ! -d "${WP_CONTENT_DIR}" ]]; then finish "${ERR_NO_WORDPRESS}" "${WP_CONTENT_DIR} not found - is wordpress installed?"; fi
if 

if [[ $(basename $0) == "setup-multisite" ]]; then main "$@"; fi
